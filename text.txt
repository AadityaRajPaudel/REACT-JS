1.
  Why react? Because its less imperative(how the program does: complete steps/code given) and more declarative(what the program does: more abstraction), meaning we dont need long JS code just to append an element that contains some content and its class name. (this takes 4 lines at min), whereas JSX allows this in single line through ReactDOM.render(html_content, destination)

2.
  ReactDOM is a global variable available by importing react-dom library

3.
  function Element(){  // note capital E
    return (
      <div> Div </div>
    )
  }
  ReactDOM.render(<Element/>, ...) // <Element/> --> calling or instantiating a component
  A function that returns a react element is called component

4.
  JSX is a syntax extension of JS that allows us to write HTML code within JS code. It is more readable.

5. 
  Components return React elements (or return HTML elements or objects)
  React components are aka UI.
  React elements are normal objects in react representing a DOM element. Eg: const root = <h1> This is a DOM element </h1>
  'root' is react element

6. 
  VITE:
  Building React App gets much quicker with quick bundling time using esbuild. 
  Unlike 
    npx create-react-app
    cd my-app
    npm start
  Vite uses:
    npm create vite@latest
    select name, framework, script type
    npm install
    npm run dev

// newer version
  const root = ReactDOM.createRoot(document.getElementById('root'));
  root.render(<App/>);

  # main.jsx only displays the <App/>
  # App.jsx takes child components

7. In summary, Node.js is the runtime that allows you to run JavaScript on the server, while Express.js is a framework that makes it easier to build web applications and APIs using Node.js. 

8. Component composition is a fundamental concept in React that allows us to build complex UIs by combining smaller, independent components

9. In index.css, main components of page are styled like body, button, etc (global styling)
    In app.css, app.jsx components are styled (component styling)

10. Just like a hardcoded function returns nothing but same result everytime, a react component also returns hard coded output if props are not used, meaning it will always give same return value as output which is non benifitial in dynamic output list like in youtube, airbnb, etc.

11. destructuring props/objects
  export default function Contact (props) {
    // code eg. props.name;
  }
  let {name, email} = props; --> in name and email variables, props.name and props.email is stored. This is destructuring.
  so we can import props as:
  export default function Contact({name, phone, img, email}) {
    // code eg. name
  }

12. to pass any other datatype values to props instead of string, we do
  <Contact
    prop = {10} or {true} or {[{}, {}, {}]} and so on
  />

13. import React from 'react';

  const arrayOfComponents = [<Component1 />, <Component2 />, <Component3 />];

  function App() {
    return (
      <div>
        {arrayOfComponents}
      </div>
    );
  }

  export default App;

  In this example, if arrayOfComponents is an array of React components, placing {arrayOfComponents} within the <div> will cause React to render each component in the array.

14. While using .map() to map raw data from another file, all the Components stored in array must have an unique prop named 'key'.
    This key prop will always have some unique value like 'id' as it is a part of a stored data.
    Using this key as prop removes the warning in console

15. props are immutable, meaning that they shouldn't be changed within a component body. The props passed to compenent can be changed during the component call but not inside the component definition itself.

16. States are values that are defined within a component and can change.

17. React.useState("Hello") ; returns an array with two items, string and function, string="Hello"

18. Object destructuring

  const person = {
       img: "./images/mr-whiskerson.png",
       name: "Mr. Whiskerson",
       phone: "(800) 555-1234",
       email: "mr.whiskaz@catnap.meow"
   }

   const {img, name} = person
   console.log(name) -> Mr.Whiskerson

  Array destructuring
  const array = ["Aaditya", "Two", "abish"];
  const [roll1, roll2, roll3] = array;

19. Note: if you ever need the old value of state
     * to help you determine the new value of state,
     * you should pass a callback function to your
     * state setter function instead of using
     * state directly. This callback function will
     * receive the old value of state as its parameter,
     * which you can then use to determine your new
     * value of state.

20. Using states in child components from the props received from parent components is depricated. Those states are called derived states.
  Rather use the function of parent component in child as props Eg in toggle div program

21. ternary are used when we want to display one or the other thing, and && is used when we want to display a thing or nothing
  using (true && jsx element) is standard format
  ternary and && can be used directly in return statement of component, whereas if stateement for handling multiple condition based rendering should be done above the return in component

22. to handle multiple form inputs, we save an object as state containing property names as input element's name property.
  then a generalized function is made to handle the changes in the input field. Then any change in any field can update the state object containing all data of fields.
  We should give a value attribute to input element eg: <input name="firstname" value = {formdata.firstname}/> to make sure its the state thats determining the input field value rather than the other way round.

23. <input 
        type="checkbox" 
        id="isFriendly" 
    />
    <label htmlFor="isFriendly">Are you friendly?</label>

    to make label and checkboxes associated with each other

24. Checkbox has checked attribute that is a boolean, in state, its value is saved as boolean, like
    eg: are you friendly? checkbox can have its state property name as 'isFriendly' and value as a bool 

25. similarly radio has both checked(bool) and value(string) attributes in input tag on top of all other attributes.
  <input type="radio" name="employee" value="part time" checked= {formData.employee === "part time"} />
  <input type="radio" name="employee" value="full time" checked= {formData.employee === "full time"} />